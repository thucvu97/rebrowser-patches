--- a/src/cdp/Browser.ts	
+++ b/src/cdp/Browser.ts	
@@ -338,6 +338,11 @@
     return await this.#defaultContext.newPage();
   }
 
+  // rebrowser-patches: expose browser CDP session
+  _connection(): Connection {
+    return this.#connection;
+  }
+
   async _createPageInContext(contextId?: string): Promise<Page> {
     const {targetId} = await this.#connection.send('Target.createTarget', {
       url: 'about:blank',

--- a/src/cdp/ExecutionContext.ts	
+++ b/src/cdp/ExecutionContext.ts	
@@ -78,6 +78,7 @@
   #client: CDPSession;
   #world: IsolatedWorld;
   #id: number;
+  _frameId: any;
   #name?: string;
 
   readonly #disposables = new DisposableStack();
@@ -94,16 +95,22 @@
     if (contextPayload.name) {
       this.#name = contextPayload.name;
     }
+    // rebrowser-patches: keep frameId to use later
+    if (contextPayload.auxData?.frameId) {
+      this._frameId = contextPayload.auxData?.frameId;
+    }
     const clientEmitter = this.#disposables.use(new EventEmitter(this.#client));
     clientEmitter.on('Runtime.bindingCalled', this.#onBindingCalled.bind(this));
-    clientEmitter.on('Runtime.executionContextDestroyed', async event => {
-      if (event.executionContextId === this.#id) {
+    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === '0') {
+      clientEmitter.on('Runtime.executionContextDestroyed', async event => {
+        if (event.executionContextId === this.#id) {
+          this[disposeSymbol]();
+        }
+      });
+      clientEmitter.on('Runtime.executionContextsCleared', async () => {
         this[disposeSymbol]();
-      }
-    });
-    clientEmitter.on('Runtime.executionContextsCleared', async () => {
-      this[disposeSymbol]();
-    });
+      });
+    }
     clientEmitter.on('Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this));
     clientEmitter.on(CDPSessionEvent.Disconnected, () => {
       this[disposeSymbol]();
@@ -351,6 +358,74 @@
     return await this.#evaluate(false, pageFunction, ...args);
   }
 
+  // rebrowser-patches: alternative to dispose
+  clear(newId: any) {
+    this.#id = newId
+    this.#bindings = new Map()
+    this.#bindingsInstalled = false
+    this.#puppeteerUtil = undefined
+  }
+  // rebrowser-patches: get context id if it's missing
+  async acquireContextId() {
+    if (this.#id > 0) {
+      return
+    }
+
+    const fixMode = process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] || 'alwaysIsolated'
+    process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] id = ${this.#id}, name = ${this.#name}, fixMode = ${fixMode}`)
+
+    let contextId: any
+    if (fixMode === 'alwaysIsolated') {
+      if (this.#id === -3) {
+        throw new Error('[rebrowser-patches] web workers are not supported in alwaysIsolated mode')
+      }
+
+      const sendRes = await this.#client
+        .send('Page.createIsolatedWorld', {
+          frameId: this._frameId,
+          worldName: this.#name,
+          grantUniveralAccess: true,
+        })
+      process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] Page.createIsolatedWorld result:`, sendRes)
+      contextId = sendRes.executionContextId
+    } else if (fixMode === 'enableDisable') {
+      const executionContextCreatedHandler = ({ context }: any) => {
+        process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][executionContextCreated] this.#id = ${this.#id}, name = ${this.#name}, contextId = ${contextId}, event.context.id = ${context.id}`)
+
+        if (contextId > 0) {
+          // already acquired the id
+          return
+        }
+
+        if (this.#id === -1) {
+          // main world
+          if (context.auxData && context.auxData['isDefault']) {
+            contextId = context.id
+          }
+        } else if (this.#id === -2) {
+          // utility world
+          if (this.#name === context.name) {
+            contextId = context.id
+          }
+        } else if (this.#id === -3) {
+          // web worker
+          contextId = context.id
+        }
+      }
+
+      this.#client.on('Runtime.executionContextCreated', executionContextCreatedHandler)
+      await this.#client.send('Runtime.enable')
+      await this.#client.send('Runtime.disable')
+      this.#client.off('Runtime.executionContextCreated', executionContextCreatedHandler)
+    }
+
+    if (!contextId) {
+      throw new Error('[rebrowser-patches] acquireContextId failed')
+    }
+
+    this.#id = contextId
+  }
+
   async #evaluate<
     Params extends unknown[],
     Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,
@@ -375,6 +450,13 @@
     pageFunction: Func | string,
     ...args: Params
   ): Promise<HandleFor<Awaited<ReturnType<Func>>> | Awaited<ReturnType<Func>>> {
+    // rebrowser-patches: context id is missing, acquire it and try again
+    if (this.#id < 0) {
+      await this.acquireContextId()
+      // @ts-ignore
+      return this.#evaluate(returnByValue, pageFunction, ...args)
+    }
+
     const sourceUrlComment = getSourceUrlComment(
       getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ??
         PuppeteerURL.INTERNAL_URL

--- a/src/cdp/FrameManager.ts	
+++ b/src/cdp/FrameManager.ts	
@@ -187,6 +187,10 @@
       this.#onFrameStoppedLoading(event.frameId);
     });
     session.on('Runtime.executionContextCreated', async event => {
+      if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+        // rebrowser-patches: ignore default logic
+        return
+      }
       await this.#frameTreeHandled?.valueOrThrow();
       this.#onExecutionContextCreated(event.context, session);
     });
@@ -212,9 +216,17 @@
           this.#frameTreeHandled?.resolve();
         }),
         client.send('Page.setLifecycleEventsEnabled', {enabled: true}),
-        client.send('Runtime.enable').then(() => {
-          return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
-        }),
+        (() => {
+          // rebrowser-patches: skip Runtime.enable
+          if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][FrameManager] initialize')
+            return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME)
+          }
+
+          return client.send('Runtime.enable').then(() => {
+            return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
+          })
+        })(),
         ...(frame
           ? Array.from(this.#scriptsToEvaluateOnNewDocument.values())
           : []
@@ -225,6 +237,30 @@
           return frame?.addExposedFunctionBinding(binding);
         }),
       ]);
+
+      // rebrowser-patches: manually create main world context
+      if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+        this.frames()
+          .filter(frame => {
+            return frame.client === client;
+          }).map(frame => {
+          const world = frame.worlds[MAIN_WORLD]
+          const contextPayload = {
+            id: -1,
+            name: '',
+            auxData: {
+              frameId: frame._id,
+            }
+          }
+          const context = new ExecutionContext(
+            frame.client,
+            // @ts-ignore
+            contextPayload,
+            world
+          );
+          world.setContext(context);
+        })
+      }
     } catch (error) {
       this.#frameTreeHandled?.resolve();
       // The target might have been closed before the initialization finished.
@@ -450,6 +486,24 @@
       this._frameTree.addFrame(frame);
     }
 
+    // rebrowser-patches: we cannot fully dispose contexts as they won't be recreated as we don't have Runtime events,
+    // instead, just mark it all empty
+    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+      process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches] onFrameNavigated, navigationType = ${navigationType}, id = ${framePayload.id}, url = ${framePayload.url}`)
+      for (const worldSymbol of [MAIN_WORLD, PUPPETEER_WORLD]) {
+        // @ts-ignore
+        if (frame.worlds[worldSymbol].context) {
+          // @ts-ignore
+          const frameOrWorker = frame.worlds[worldSymbol].environment
+          if ('clearDocumentHandle' in frameOrWorker) {
+            frameOrWorker.clearDocumentHandle();
+          }
+          // @ts-ignore
+          frame.worlds[worldSymbol].context?.clear(worldSymbol === MAIN_WORLD ? -1 : -2)
+        }
+      }
+    }
+
     frame = await this._frameTree.waitForFrame(frameId);
     frame._navigated(framePayload);
     this.emit(FrameManagerEvent.FrameNavigated, frame);
@@ -482,6 +536,24 @@
               worldName: name,
               grantUniveralAccess: true,
             })
+            .then((createIsolatedWorldResult: any) => {
+              // rebrowser-patches: save created context id
+              if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === '0') {
+                return
+              }
+              if (!createIsolatedWorldResult?.executionContextId) {
+                // probably "Target closed" error, just ignore it
+                return
+              }
+              // @ts-ignore
+              this.#onExecutionContextCreated({
+                id: createIsolatedWorldResult.executionContextId,
+                name,
+                auxData: {
+                  frameId: frame._id,
+                }
+              }, frame.client)
+            })
             .catch(debugError);
         })
     );

--- a/src/cdp/IsolatedWorld.ts	
+++ b/src/cdp/IsolatedWorld.ts	
@@ -204,6 +204,8 @@
     if (!context) {
       context = await this.#waitForExecutionContext();
     }
+    // rebrowser-patches: make sure id is acquired
+    await context.acquireContextId()
     const {object} = await this.client.send('DOM.resolveNode', {
       backendNodeId: backendNodeId,
       executionContextId: context.id,

--- a/src/cdp/WebWorker.ts	
+++ b/src/cdp/WebWorker.ts	
@@ -56,6 +56,10 @@
     this.#world = new IsolatedWorld(this, new TimeoutSettings());
 
     this.#client.once('Runtime.executionContextCreated', async event => {
+      if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+        // rebrowser-patches: ignore default logic
+        return
+      }
       this.#world.setContext(
         new ExecutionContext(client, event.context, this.#world)
       );
@@ -78,8 +82,20 @@
       this.#world.dispose();
     });
 
-    // This might fail if the target is closed before we receive all execution contexts.
-    this.#client.send('Runtime.enable').catch(debugError);
+    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+      // @ts-ignore
+      process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][WebWorker] initialize', targetType, targetId, client._target(), client._target()._getTargetInfo())
+
+      // rebrowser-patches: manually create context
+      const contextPayload = {
+        id: -3,
+      }
+      // @ts-ignore
+      this.#world.setContext(new ExecutionContext(client, contextPayload, this.#world));
+    } else {
+      // This might fail if the target is closed before we receive all execution contexts.
+      this.#client.send('Runtime.enable').catch(debugError);
+    }
   }
 
   mainRealm(): Realm {

--- a/src/common/util.ts	
+++ b/src/common/util.ts	
@@ -328,7 +328,9 @@
  * @internal
  */
 export const UTILITY_WORLD_NAME =
-  '__puppeteer_utility_world__' + packageVersion;
+  // rebrowser-patches: change utility world name
+  process.env['REBROWSER_PATCHES_UTILITY_WORLD_NAME'] !== '0' ? (process.env['REBROWSER_PATCHES_UTILITY_WORLD_NAME'] || 'util') :
+    '__puppeteer_utility_world__' + packageVersion;
 
 /**
  * @internal
@@ -338,6 +340,10 @@
  * @internal
  */
 export function getSourceUrlComment(url: string): string {
+  // rebrowser-patches: change sourceUrl to generic script name
+  if (process.env['REBROWSER_PATCHES_SOURCE_URL'] !== '0') {
+    url = process.env['REBROWSER_PATCHES_SOURCE_URL'] || 'app.js'
+  }
   return `//# sourceURL=${url}`;
 }
 

--- a/lib/cjs/puppeteer/cdp/Browser.d.ts	
+++ b/lib/cjs/puppeteer/cdp/Browser.d.ts	
@@ -32,6 +32,7 @@
     _disposeContext(contextId?: string): Promise<void>;
     wsEndpoint(): string;
     newPage(): Promise<Page>;
+    _connection(): Connection;
     _createPageInContext(contextId?: string): Promise<Page>;
     targets(): CdpTarget[];
     target(): CdpTarget;

--- a/lib/cjs/puppeteer/cdp/Browser.js	
+++ b/lib/cjs/puppeteer/cdp/Browser.js	
@@ -176,6 +176,10 @@
     async newPage() {
         return await this.#defaultContext.newPage();
     }
+    // rebrowser-patches: expose browser CDP session
+    _connection() {
+        return this.#connection;
+    }
     async _createPageInContext(contextId) {
         const { targetId } = await this.#connection.send('Target.createTarget', {
             url: 'about:blank',

--- a/lib/cjs/puppeteer/cdp/ExecutionContext.d.ts	
+++ b/lib/cjs/puppeteer/cdp/ExecutionContext.d.ts	
@@ -22,6 +22,7 @@
     bindingcalled: Protocol.Runtime.BindingCalledEvent;
 }> implements Disposable {
     #private;
+    _frameId: any;
     constructor(client: CDPSession, contextPayload: Protocol.Runtime.ExecutionContextDescription, world: IsolatedWorld);
     get id(): number;
     get puppeteerUtil(): Promise<JSHandle<PuppeteerUtil>>;
@@ -116,6 +117,8 @@
      * {@link ElementHandle | element handle}.
      */
     evaluateHandle<Params extends unknown[], Func extends EvaluateFunc<Params> = EvaluateFunc<Params>>(pageFunction: Func | string, ...args: Params): Promise<HandleFor<Awaited<ReturnType<Func>>>>;
+    clear(newId: any): void;
+    acquireContextId(): Promise<void>;
     [disposeSymbol](): void;
 }
 //# sourceMappingURL=ExecutionContext.d.ts.map
\ No newline at end of file

--- a/lib/cjs/puppeteer/cdp/ExecutionContext.js	
+++ b/lib/cjs/puppeteer/cdp/ExecutionContext.js	
@@ -81,6 +81,7 @@
     #client;
     #world;
     #id;
+    _frameId;
     #name;
     #disposables = new disposable_js_1.DisposableStack();
     constructor(client, contextPayload, world) {
@@ -91,16 +92,22 @@
         if (contextPayload.name) {
             this.#name = contextPayload.name;
         }
+        // rebrowser-patches: keep frameId to use later
+        if (contextPayload.auxData?.frameId) {
+            this._frameId = contextPayload.auxData?.frameId;
+        }
         const clientEmitter = this.#disposables.use(new EventEmitter_js_1.EventEmitter(this.#client));
         clientEmitter.on('Runtime.bindingCalled', this.#onBindingCalled.bind(this));
-        clientEmitter.on('Runtime.executionContextDestroyed', async (event) => {
-            if (event.executionContextId === this.#id) {
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === '0') {
+            clientEmitter.on('Runtime.executionContextDestroyed', async (event) => {
+                if (event.executionContextId === this.#id) {
+                    this[disposable_js_1.disposeSymbol]();
+                }
+            });
+            clientEmitter.on('Runtime.executionContextsCleared', async () => {
                 this[disposable_js_1.disposeSymbol]();
-            }
-        });
-        clientEmitter.on('Runtime.executionContextsCleared', async () => {
-            this[disposable_js_1.disposeSymbol]();
-        });
+            });
+        }
         clientEmitter.on('Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this));
         clientEmitter.on(CDPSession_js_1.CDPSessionEvent.Disconnected, () => {
             this[disposable_js_1.disposeSymbol]();
@@ -324,7 +331,75 @@
     async evaluateHandle(pageFunction, ...args) {
         return await this.#evaluate(false, pageFunction, ...args);
     }
+    // rebrowser-patches: alternative to dispose
+    clear(newId) {
+        this.#id = newId;
+        this.#bindings = new Map();
+        this.#bindingsInstalled = false;
+        this.#puppeteerUtil = undefined;
+    }
+    // rebrowser-patches: get context id if it's missing
+    async acquireContextId() {
+        if (this.#id > 0) {
+            return;
+        }
+        const fixMode = process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] || 'alwaysIsolated';
+        process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] id = ${this.#id}, name = ${this.#name}, fixMode = ${fixMode}`);
+        let contextId;
+        if (fixMode === 'alwaysIsolated') {
+            if (this.#id === -3) {
+                throw new Error('[rebrowser-patches] web workers are not supported in alwaysIsolated mode');
+            }
+            const sendRes = await this.#client
+                .send('Page.createIsolatedWorld', {
+                frameId: this._frameId,
+                worldName: this.#name,
+                grantUniveralAccess: true,
+            });
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] Page.createIsolatedWorld result:`, sendRes);
+            contextId = sendRes.executionContextId;
+        }
+        else if (fixMode === 'enableDisable') {
+            const executionContextCreatedHandler = ({ context }) => {
+                process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][executionContextCreated] this.#id = ${this.#id}, name = ${this.#name}, contextId = ${contextId}, event.context.id = ${context.id}`);
+                if (contextId > 0) {
+                    // already acquired the id
+                    return;
+                }
+                if (this.#id === -1) {
+                    // main world
+                    if (context.auxData && context.auxData['isDefault']) {
+                        contextId = context.id;
+                    }
+                }
+                else if (this.#id === -2) {
+                    // utility world
+                    if (this.#name === context.name) {
+                        contextId = context.id;
+                    }
+                }
+                else if (this.#id === -3) {
+                    // web worker
+                    contextId = context.id;
+                }
+            };
+            this.#client.on('Runtime.executionContextCreated', executionContextCreatedHandler);
+            await this.#client.send('Runtime.enable');
+            await this.#client.send('Runtime.disable');
+            this.#client.off('Runtime.executionContextCreated', executionContextCreatedHandler);
+        }
+        if (!contextId) {
+            throw new Error('[rebrowser-patches] acquireContextId failed');
+        }
+        this.#id = contextId;
+    }
     async #evaluate(returnByValue, pageFunction, ...args) {
+        // rebrowser-patches: context id is missing, acquire it and try again
+        if (this.#id < 0) {
+            await this.acquireContextId();
+            // @ts-ignore
+            return this.#evaluate(returnByValue, pageFunction, ...args);
+        }
         const sourceUrlComment = (0, util_js_1.getSourceUrlComment)((0, util_js_1.getSourcePuppeteerURLIfAvailable)(pageFunction)?.toString() ??
             util_js_1.PuppeteerURL.INTERNAL_URL);
         if ((0, util_js_1.isString)(pageFunction)) {

--- a/lib/cjs/puppeteer/cdp/FrameManager.js	
+++ b/lib/cjs/puppeteer/cdp/FrameManager.js	
@@ -150,6 +150,10 @@
             this.#onFrameStoppedLoading(event.frameId);
         });
         session.on('Runtime.executionContextCreated', async (event) => {
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                // rebrowser-patches: ignore default logic
+                return;
+            }
             await this.#frameTreeHandled?.valueOrThrow();
             this.#onExecutionContextCreated(event.context, session);
         });
@@ -174,9 +178,16 @@
                     this.#frameTreeHandled?.resolve();
                 }),
                 client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
-                client.send('Runtime.enable').then(() => {
-                    return this.#createIsolatedWorld(client, util_js_1.UTILITY_WORLD_NAME);
-                }),
+                (() => {
+                    // rebrowser-patches: skip Runtime.enable
+                    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                        process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][FrameManager] initialize');
+                        return this.#createIsolatedWorld(client, util_js_1.UTILITY_WORLD_NAME);
+                    }
+                    return client.send('Runtime.enable').then(() => {
+                        return this.#createIsolatedWorld(client, util_js_1.UTILITY_WORLD_NAME);
+                    });
+                })(),
                 ...(frame
                     ? Array.from(this.#scriptsToEvaluateOnNewDocument.values())
                     : []).map(script => {
@@ -186,6 +197,26 @@
                     return frame?.addExposedFunctionBinding(binding);
                 }),
             ]);
+            // rebrowser-patches: manually create main world context
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                this.frames()
+                    .filter(frame => {
+                    return frame.client === client;
+                }).map(frame => {
+                    const world = frame.worlds[IsolatedWorlds_js_1.MAIN_WORLD];
+                    const contextPayload = {
+                        id: -1,
+                        name: '',
+                        auxData: {
+                            frameId: frame._id,
+                        }
+                    };
+                    const context = new ExecutionContext_js_1.ExecutionContext(frame.client, 
+                    // @ts-ignore
+                    contextPayload, world);
+                    world.setContext(context);
+                });
+            }
         }
         catch (error) {
             this.#frameTreeHandled?.resolve();
@@ -353,6 +384,23 @@
             }
             this._frameTree.addFrame(frame);
         }
+        // rebrowser-patches: we cannot fully dispose contexts as they won't be recreated as we don't have Runtime events,
+        // instead, just mark it all empty
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches] onFrameNavigated, navigationType = ${navigationType}, id = ${framePayload.id}, url = ${framePayload.url}`);
+            for (const worldSymbol of [IsolatedWorlds_js_1.MAIN_WORLD, IsolatedWorlds_js_1.PUPPETEER_WORLD]) {
+                // @ts-ignore
+                if (frame.worlds[worldSymbol].context) {
+                    // @ts-ignore
+                    const frameOrWorker = frame.worlds[worldSymbol].environment;
+                    if ('clearDocumentHandle' in frameOrWorker) {
+                        frameOrWorker.clearDocumentHandle();
+                    }
+                    // @ts-ignore
+                    frame.worlds[worldSymbol].context?.clear(worldSymbol === IsolatedWorlds_js_1.MAIN_WORLD ? -1 : -2);
+                }
+            }
+        }
         frame = await this._frameTree.waitForFrame(frameId);
         frame._navigated(framePayload);
         this.emit(FrameManagerEvents_js_1.FrameManagerEvent.FrameNavigated, frame);
@@ -380,6 +428,24 @@
                 worldName: name,
                 grantUniveralAccess: true,
             })
+                .then((createIsolatedWorldResult) => {
+                // rebrowser-patches: save created context id
+                if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === '0') {
+                    return;
+                }
+                if (!createIsolatedWorldResult?.executionContextId) {
+                    // probably "Target closed" error, just ignore it
+                    return;
+                }
+                // @ts-ignore
+                this.#onExecutionContextCreated({
+                    id: createIsolatedWorldResult.executionContextId,
+                    name,
+                    auxData: {
+                        frameId: frame._id,
+                    }
+                }, frame.client);
+            })
                 .catch(util_js_1.debugError);
         }));
         this.#isolatedWorlds.add(key);

--- a/lib/cjs/puppeteer/cdp/IsolatedWorld.js	
+++ b/lib/cjs/puppeteer/cdp/IsolatedWorld.js	
@@ -106,6 +106,8 @@
         if (!context) {
             context = await this.#waitForExecutionContext();
         }
+        // rebrowser-patches: make sure id is acquired
+        await context.acquireContextId();
         const { object } = await this.client.send('DOM.resolveNode', {
             backendNodeId: backendNodeId,
             executionContextId: context.id,

--- a/lib/cjs/puppeteer/cdp/WebWorker.js	
+++ b/lib/cjs/puppeteer/cdp/WebWorker.js	
@@ -24,6 +24,10 @@
         this.#targetType = targetType;
         this.#world = new IsolatedWorld_js_1.IsolatedWorld(this, new TimeoutSettings_js_1.TimeoutSettings());
         this.#client.once('Runtime.executionContextCreated', async (event) => {
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                // rebrowser-patches: ignore default logic
+                return;
+            }
             this.#world.setContext(new ExecutionContext_js_1.ExecutionContext(client, event.context, this.#world));
         });
         this.#world.emitter.on('consoleapicalled', async (event) => {
@@ -40,8 +44,20 @@
         this.#client.once(CDPSession_js_1.CDPSessionEvent.Disconnected, () => {
             this.#world.dispose();
         });
-        // This might fail if the target is closed before we receive all execution contexts.
-        this.#client.send('Runtime.enable').catch(util_js_1.debugError);
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+            // @ts-ignore
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][WebWorker] initialize', targetType, targetId, client._target(), client._target()._getTargetInfo());
+            // rebrowser-patches: manually create context
+            const contextPayload = {
+                id: -3,
+            };
+            // @ts-ignore
+            this.#world.setContext(new ExecutionContext_js_1.ExecutionContext(client, contextPayload, this.#world));
+        }
+        else {
+            // This might fail if the target is closed before we receive all execution contexts.
+            this.#client.send('Runtime.enable').catch(util_js_1.debugError);
+        }
     }
     mainRealm() {
         return this.#world;

--- a/lib/cjs/puppeteer/common/util.js	
+++ b/lib/cjs/puppeteer/common/util.js	
@@ -294,7 +294,10 @@
 /**
  * @internal
  */
-exports.UTILITY_WORLD_NAME = '__puppeteer_utility_world__' + version_js_1.packageVersion;
+exports.UTILITY_WORLD_NAME = 
+// rebrowser-patches: change utility world name
+process.env['REBROWSER_PATCHES_UTILITY_WORLD_NAME'] !== '0' ? (process.env['REBROWSER_PATCHES_UTILITY_WORLD_NAME'] || 'util') :
+    '__puppeteer_utility_world__' + version_js_1.packageVersion;
 /**
  * @internal
  */
@@ -303,6 +306,10 @@
  * @internal
  */
 function getSourceUrlComment(url) {
+    // rebrowser-patches: change sourceUrl to generic script name
+    if (process.env['REBROWSER_PATCHES_SOURCE_URL'] !== '0') {
+        url = process.env['REBROWSER_PATCHES_SOURCE_URL'] || 'app.js';
+    }
     return `//# sourceURL=${url}`;
 }
 exports.getSourceUrlComment = getSourceUrlComment;

--- a/lib/esm/puppeteer/cdp/Browser.d.ts	
+++ b/lib/esm/puppeteer/cdp/Browser.d.ts	
@@ -32,6 +32,7 @@
     _disposeContext(contextId?: string): Promise<void>;
     wsEndpoint(): string;
     newPage(): Promise<Page>;
+    _connection(): Connection;
     _createPageInContext(contextId?: string): Promise<Page>;
     targets(): CdpTarget[];
     target(): CdpTarget;

--- a/lib/esm/puppeteer/cdp/Browser.js	
+++ b/lib/esm/puppeteer/cdp/Browser.js	
@@ -173,6 +173,10 @@
     async newPage() {
         return await this.#defaultContext.newPage();
     }
+    // rebrowser-patches: expose browser CDP session
+    _connection() {
+        return this.#connection;
+    }
     async _createPageInContext(contextId) {
         const { targetId } = await this.#connection.send('Target.createTarget', {
             url: 'about:blank',

--- a/lib/esm/puppeteer/cdp/ExecutionContext.d.ts	
+++ b/lib/esm/puppeteer/cdp/ExecutionContext.d.ts	
@@ -22,6 +22,7 @@
     bindingcalled: Protocol.Runtime.BindingCalledEvent;
 }> implements Disposable {
     #private;
+    _frameId: any;
     constructor(client: CDPSession, contextPayload: Protocol.Runtime.ExecutionContextDescription, world: IsolatedWorld);
     get id(): number;
     get puppeteerUtil(): Promise<JSHandle<PuppeteerUtil>>;
@@ -116,6 +117,8 @@
      * {@link ElementHandle | element handle}.
      */
     evaluateHandle<Params extends unknown[], Func extends EvaluateFunc<Params> = EvaluateFunc<Params>>(pageFunction: Func | string, ...args: Params): Promise<HandleFor<Awaited<ReturnType<Func>>>>;
+    clear(newId: any): void;
+    acquireContextId(): Promise<void>;
     [disposeSymbol](): void;
 }
 //# sourceMappingURL=ExecutionContext.d.ts.map
\ No newline at end of file

--- a/lib/esm/puppeteer/cdp/ExecutionContext.js	
+++ b/lib/esm/puppeteer/cdp/ExecutionContext.js	
@@ -78,6 +78,7 @@
     #client;
     #world;
     #id;
+    _frameId;
     #name;
     #disposables = new DisposableStack();
     constructor(client, contextPayload, world) {
@@ -88,16 +89,22 @@
         if (contextPayload.name) {
             this.#name = contextPayload.name;
         }
+        // rebrowser-patches: keep frameId to use later
+        if (contextPayload.auxData?.frameId) {
+            this._frameId = contextPayload.auxData?.frameId;
+        }
         const clientEmitter = this.#disposables.use(new EventEmitter(this.#client));
         clientEmitter.on('Runtime.bindingCalled', this.#onBindingCalled.bind(this));
-        clientEmitter.on('Runtime.executionContextDestroyed', async (event) => {
-            if (event.executionContextId === this.#id) {
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === '0') {
+            clientEmitter.on('Runtime.executionContextDestroyed', async (event) => {
+                if (event.executionContextId === this.#id) {
+                    this[disposeSymbol]();
+                }
+            });
+            clientEmitter.on('Runtime.executionContextsCleared', async () => {
                 this[disposeSymbol]();
-            }
-        });
-        clientEmitter.on('Runtime.executionContextsCleared', async () => {
-            this[disposeSymbol]();
-        });
+            });
+        }
         clientEmitter.on('Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this));
         clientEmitter.on(CDPSessionEvent.Disconnected, () => {
             this[disposeSymbol]();
@@ -321,7 +328,75 @@
     async evaluateHandle(pageFunction, ...args) {
         return await this.#evaluate(false, pageFunction, ...args);
     }
+    // rebrowser-patches: alternative to dispose
+    clear(newId) {
+        this.#id = newId;
+        this.#bindings = new Map();
+        this.#bindingsInstalled = false;
+        this.#puppeteerUtil = undefined;
+    }
+    // rebrowser-patches: get context id if it's missing
+    async acquireContextId() {
+        if (this.#id > 0) {
+            return;
+        }
+        const fixMode = process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] || 'alwaysIsolated';
+        process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] id = ${this.#id}, name = ${this.#name}, fixMode = ${fixMode}`);
+        let contextId;
+        if (fixMode === 'alwaysIsolated') {
+            if (this.#id === -3) {
+                throw new Error('[rebrowser-patches] web workers are not supported in alwaysIsolated mode');
+            }
+            const sendRes = await this.#client
+                .send('Page.createIsolatedWorld', {
+                frameId: this._frameId,
+                worldName: this.#name,
+                grantUniveralAccess: true,
+            });
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][acquireContextId] Page.createIsolatedWorld result:`, sendRes);
+            contextId = sendRes.executionContextId;
+        }
+        else if (fixMode === 'enableDisable') {
+            const executionContextCreatedHandler = ({ context }) => {
+                process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches][executionContextCreated] this.#id = ${this.#id}, name = ${this.#name}, contextId = ${contextId}, event.context.id = ${context.id}`);
+                if (contextId > 0) {
+                    // already acquired the id
+                    return;
+                }
+                if (this.#id === -1) {
+                    // main world
+                    if (context.auxData && context.auxData['isDefault']) {
+                        contextId = context.id;
+                    }
+                }
+                else if (this.#id === -2) {
+                    // utility world
+                    if (this.#name === context.name) {
+                        contextId = context.id;
+                    }
+                }
+                else if (this.#id === -3) {
+                    // web worker
+                    contextId = context.id;
+                }
+            };
+            this.#client.on('Runtime.executionContextCreated', executionContextCreatedHandler);
+            await this.#client.send('Runtime.enable');
+            await this.#client.send('Runtime.disable');
+            this.#client.off('Runtime.executionContextCreated', executionContextCreatedHandler);
+        }
+        if (!contextId) {
+            throw new Error('[rebrowser-patches] acquireContextId failed');
+        }
+        this.#id = contextId;
+    }
     async #evaluate(returnByValue, pageFunction, ...args) {
+        // rebrowser-patches: context id is missing, acquire it and try again
+        if (this.#id < 0) {
+            await this.acquireContextId();
+            // @ts-ignore
+            return this.#evaluate(returnByValue, pageFunction, ...args);
+        }
         const sourceUrlComment = getSourceUrlComment(getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ??
             PuppeteerURL.INTERNAL_URL);
         if (isString(pageFunction)) {

--- a/lib/esm/puppeteer/cdp/FrameManager.js	
+++ b/lib/esm/puppeteer/cdp/FrameManager.js	
@@ -147,6 +147,10 @@
             this.#onFrameStoppedLoading(event.frameId);
         });
         session.on('Runtime.executionContextCreated', async (event) => {
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                // rebrowser-patches: ignore default logic
+                return;
+            }
             await this.#frameTreeHandled?.valueOrThrow();
             this.#onExecutionContextCreated(event.context, session);
         });
@@ -171,9 +175,16 @@
                     this.#frameTreeHandled?.resolve();
                 }),
                 client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
-                client.send('Runtime.enable').then(() => {
-                    return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
-                }),
+                (() => {
+                    // rebrowser-patches: skip Runtime.enable
+                    if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                        process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][FrameManager] initialize');
+                        return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
+                    }
+                    return client.send('Runtime.enable').then(() => {
+                        return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
+                    });
+                })(),
                 ...(frame
                     ? Array.from(this.#scriptsToEvaluateOnNewDocument.values())
                     : []).map(script => {
@@ -183,6 +194,26 @@
                     return frame?.addExposedFunctionBinding(binding);
                 }),
             ]);
+            // rebrowser-patches: manually create main world context
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                this.frames()
+                    .filter(frame => {
+                    return frame.client === client;
+                }).map(frame => {
+                    const world = frame.worlds[MAIN_WORLD];
+                    const contextPayload = {
+                        id: -1,
+                        name: '',
+                        auxData: {
+                            frameId: frame._id,
+                        }
+                    };
+                    const context = new ExecutionContext(frame.client, 
+                    // @ts-ignore
+                    contextPayload, world);
+                    world.setContext(context);
+                });
+            }
         }
         catch (error) {
             this.#frameTreeHandled?.resolve();
@@ -350,6 +381,23 @@
             }
             this._frameTree.addFrame(frame);
         }
+        // rebrowser-patches: we cannot fully dispose contexts as they won't be recreated as we don't have Runtime events,
+        // instead, just mark it all empty
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log(`[rebrowser-patches] onFrameNavigated, navigationType = ${navigationType}, id = ${framePayload.id}, url = ${framePayload.url}`);
+            for (const worldSymbol of [MAIN_WORLD, PUPPETEER_WORLD]) {
+                // @ts-ignore
+                if (frame.worlds[worldSymbol].context) {
+                    // @ts-ignore
+                    const frameOrWorker = frame.worlds[worldSymbol].environment;
+                    if ('clearDocumentHandle' in frameOrWorker) {
+                        frameOrWorker.clearDocumentHandle();
+                    }
+                    // @ts-ignore
+                    frame.worlds[worldSymbol].context?.clear(worldSymbol === MAIN_WORLD ? -1 : -2);
+                }
+            }
+        }
         frame = await this._frameTree.waitForFrame(frameId);
         frame._navigated(framePayload);
         this.emit(FrameManagerEvent.FrameNavigated, frame);
@@ -377,6 +425,24 @@
                 worldName: name,
                 grantUniveralAccess: true,
             })
+                .then((createIsolatedWorldResult) => {
+                // rebrowser-patches: save created context id
+                if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] === '0') {
+                    return;
+                }
+                if (!createIsolatedWorldResult?.executionContextId) {
+                    // probably "Target closed" error, just ignore it
+                    return;
+                }
+                // @ts-ignore
+                this.#onExecutionContextCreated({
+                    id: createIsolatedWorldResult.executionContextId,
+                    name,
+                    auxData: {
+                        frameId: frame._id,
+                    }
+                }, frame.client);
+            })
                 .catch(debugError);
         }));
         this.#isolatedWorlds.add(key);

--- a/lib/esm/puppeteer/cdp/IsolatedWorld.js	
+++ b/lib/esm/puppeteer/cdp/IsolatedWorld.js	
@@ -103,6 +103,8 @@
         if (!context) {
             context = await this.#waitForExecutionContext();
         }
+        // rebrowser-patches: make sure id is acquired
+        await context.acquireContextId();
         const { object } = await this.client.send('DOM.resolveNode', {
             backendNodeId: backendNodeId,
             executionContextId: context.id,

--- a/lib/esm/puppeteer/cdp/WebWorker.js	
+++ b/lib/esm/puppeteer/cdp/WebWorker.js	
@@ -21,6 +21,10 @@
         this.#targetType = targetType;
         this.#world = new IsolatedWorld(this, new TimeoutSettings());
         this.#client.once('Runtime.executionContextCreated', async (event) => {
+            if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+                // rebrowser-patches: ignore default logic
+                return;
+            }
             this.#world.setContext(new ExecutionContext(client, event.context, this.#world));
         });
         this.#world.emitter.on('consoleapicalled', async (event) => {
@@ -37,8 +41,20 @@
         this.#client.once(CDPSessionEvent.Disconnected, () => {
             this.#world.dispose();
         });
-        // This might fail if the target is closed before we receive all execution contexts.
-        this.#client.send('Runtime.enable').catch(debugError);
+        if (process.env['REBROWSER_PATCHES_RUNTIME_FIX_MODE'] !== '0') {
+            // @ts-ignore
+            process.env['REBROWSER_PATCHES_DEBUG'] && console.log('[rebrowser-patches][WebWorker] initialize', targetType, targetId, client._target(), client._target()._getTargetInfo());
+            // rebrowser-patches: manually create context
+            const contextPayload = {
+                id: -3,
+            };
+            // @ts-ignore
+            this.#world.setContext(new ExecutionContext(client, contextPayload, this.#world));
+        }
+        else {
+            // This might fail if the target is closed before we receive all execution contexts.
+            this.#client.send('Runtime.enable').catch(debugError);
+        }
     }
     mainRealm() {
         return this.#world;

--- a/lib/esm/puppeteer/common/util.js	
+++ b/lib/esm/puppeteer/common/util.js	
@@ -254,7 +254,10 @@
 /**
  * @internal
  */
-export const UTILITY_WORLD_NAME = '__puppeteer_utility_world__' + packageVersion;
+export const UTILITY_WORLD_NAME = 
+// rebrowser-patches: change utility world name
+process.env['REBROWSER_PATCHES_UTILITY_WORLD_NAME'] !== '0' ? (process.env['REBROWSER_PATCHES_UTILITY_WORLD_NAME'] || 'util') :
+    '__puppeteer_utility_world__' + packageVersion;
 /**
  * @internal
  */
@@ -263,6 +266,10 @@
  * @internal
  */
 export function getSourceUrlComment(url) {
+    // rebrowser-patches: change sourceUrl to generic script name
+    if (process.env['REBROWSER_PATCHES_SOURCE_URL'] !== '0') {
+        url = process.env['REBROWSER_PATCHES_SOURCE_URL'] || 'app.js';
+    }
     return `//# sourceURL=${url}`;
 }
 /**
